{
    "collab_server" : "",
    "contents" : "\n# Getting started with R Leaflet\n\n# Uncomment and run \"install.packages\" functions below if you have not yet installed these packages\n\n#install.packages(\"leaflet\")\nlibrary(leaflet)\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n\n\n# Putting a marker on a map\n\n# Initialize and assign m as the leaflet object\nm <- leaflet()\n# Now add tiles to it\nm <- addTiles(m)\n# Now, add a marker with a popup\nm <- addMarkers(m, lng= -111.965886, lat=33.683815, popup=\"<b>Hello</b><br><a href='http://ire.org/conferences/ire2017/'>-IRE 2017</a>\")\n# Print out the map\nm\n\n# Let's talk about pipes...\n\n# It’s easier to wrap your head around it if you think of coding grammatically. \n\n# Normal coding in R is rigid declarative sentences: “Bob is 32. Nancy is 4 years younger than Bob.” \n\n# Coding with the pipe operator: “Nancy is 4 years younger than Bob, who is 32.” \n\n# Pipes are a comma (or a semi-colon, if you want) that lets you create one long, run-on sentence.\n\n### This is the same code as above but using pipes\n\nm <- leaflet() %>%\naddTiles() %>%  \nsetView(-81.655210, 30.324303, zoom = 16) %>%\naddMarkers(lng=-81.655210, lat=30.324303, popup=\"<b>Hello</b><br><a href='http://ire.org/conferences/nicar2017/'>-NICAR 2017</a>\")\n\n# See how the m object is no longer needed to be included in every line except the first? It's just assumed now.\n\nm \n\n# Multiple locations from a csv\n\ndunkin <- read.csv(\"data/dunkin.csv\", stringsAsFactors=F)\n\n# Bringing in the DataTables package to display the data in a nice format\n# install.packages(\"DT\")\nlibrary(DT)\n\n# Using the datatable function from the DT package to see the first 6 rows of data\ndatatable(head(dunkin))\n\nm <- leaflet(dunkin) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n                                  attribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-81.655210, 30.324303, zoom = 8) %>% \n  addCircles(~lon, ~lat, popup=dunkin$type, weight = 3, radius=40, \n             color=\"#ffa500\", stroke = TRUE, fillOpacity = 0.8) \n\nm\n\n# Let's bring in some competition.\n\nstarbucks <- read.csv(\"data/starbucks.csv\", stringsAsFactors=F)\n\ndatatable(head(starbucks))\n\n# Quick aside: What if there was only address data and no latitude and longitude information?\n# To geolocate the data, there's an R package called ggmap\n\nlibrary(ggmap)\n\n# Prepping the Starbucks data for geocoding\n\n# Selecting address information columns and isolating the first 10 rows\nsb_example <- select(starbucks, Address, City, Province, Postal.Code)\nsb_example <- sb_example[1:10,]\n\n# Need a single column for addresses,\nsb_example $location <- paste0(sb_example$Address, \", \", sb_example$City, \", \", sb_example$Province, \" \", sb_example$Postal.Code)\n\ndatatable(sb_example)\n\n# This function geocodes a location (find latitude and longitude) using the Google Maps API\ngeo <- geocode(location = sb_example$location, output=\"latlon\", source=\"google\")\n\n# Bringing over the longitude and latitude data\nsb_example$lon <- geo$lon\nsb_example$lat <- geo$lat\n\ndatatable(sb_example)\n\n# Okay, moving on\n# Let's go back to the original starbucks data set\n\n# isolating just the 3 columns we're interested in-- type, lat, and lon\nsb_loc <- select(starbucks, type, lat, lon)\ndd_loc <- select(dunkin, type, lat, lon)\n\n# joining the two data frames together\nddsb <- rbind(sb_loc, dd_loc)\n\n# creating a coffee color palette\ncof <- colorFactor(c(\"#ffa500\", \"#13ED3F\"), domain=c(\"Dunkin Donuts\", \"Starbucks\"))\n\n# mapping based on type\nm <- leaflet(ddsb) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \n                                attribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \n  setView(-81.655210, 30.324303, zoom = 8) %>% \n  addCircleMarkers(~lon, ~lat, popup=ddsb$type, weight = 3, radius=4, \n                   color=~cof(type), stroke = F, fillOpacity = 0.5) \n\nm\n\n# Add a legend\n\nm <- leaflet(ddsb) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \nattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \nsetView(-81.655210, 30.324303, zoom = 8) %>% \naddCircleMarkers(~lon, ~lat, popup=ddsb$type, weight = 3, radius=4, \ncolor=~cof(type), stroke = F, fillOpacity = 0.5)  %>%\naddLegend(\"bottomright\", colors= c(\"#ffa500\", \"#13ED3F\"), labels=c(\"Dunkin'\", \"Starbucks\"), title=\"Coffee places\")\n\nm\n\n## Mapping the end of the universe\n\n# https://www.youtube.com/embed/Mb7qDfIzQRk\n\nlibrary(sp)\n\n# Here's a loop determining the distance between SB locations.\n\n# The code to do so is below, but you can skip ahead to the next chunk \n# Because it will take an hour and 45 minutes to complete \n\n# Creating a loop to go through the Starbucks dataframe and compare it itself\n# Going through each row of SB lat and lon and finding/keeping the SB lat/lon with the shortest distance to it\n\n# First, set up some temp columns\nsb_loc$sb_lat <- 0\nsb_loc$sb_lon <- 0\nsb_loc$feet <- 0\nsb_loc$string_check <- paste(sb_loc$lat, sb_loc$lon)\n\n# Now the loop\nfor (i in 1:nrow(sb_loc)) {\nprint(paste0(i, \" of \", nrow(sb_loc)))\n# Looping through the SB dataframe\n\n# slicing out each row\nsb_loc_row <- subset(sb_loc[i,])\n\n# Filtering out the sliced out row so it doesn't measure against itself\nsb_loc_compare <- subset(sb_loc, string_check!=sb_loc_row$string_check[1])\n\n# Looping through the new SB dataframe\nfor (x in 1:nrow(sb_loc_compare)) {\n\n# Using the spDistsN1 function which is a little weird because it\n#  only works if the lat lon pairs being measured are in a matrix\nto_measure_sb <- matrix(c(sb_loc_row$lon[1], sb_loc_compare$lon[x], sb_loc_row$lat[1], sb_loc_compare$lat[x]), ncol=2)\n# Comparing the entire matrix to a single row in the matrix\nkm <- spDistsN1(to_measure_sb, to_measure_sb[1,], longlat=TRUE)\n# We only care about the second result sine the first result is always zero\nkm <- km[2]\n\n# Converting kilometers to feet\nfeet <- round(km*1000/.3048,2)\n\n# These if statements replace the current SB lat and lon and feet variables \n#  with the first results but replaces that if\n#  the feet value is smaller than what's currently in it\nif (x==1) {\nsb_loc_row$sb_lat <- sb_loc_compare$lat[x]\nsb_loc_row$sb_lon <- sb_loc_compare$lon[x]\nsb_loc_row$feet <- feet\nsb_loc_row$sb_name <- sb_loc_compare$string_check[x]\n} else {\nif (feet < sb_loc_row$feet) {\nsb_loc_row$sb_lat <- sb_loc_compare$lat[x]\nsb_loc_row$sb_lon <- sb_loc_compare$lon[x]\nsb_loc_row$feet <- feet\nsb_loc_row$sb_name <- sb_loc_compare$string_check[x]\n}\n}\n}\n\n# This is rebuilding the dataframe row by row with the new SB dataframe values\nif (i==1) {\nsb_distances <- sb_loc_row\n} else {\nsb_distances <- rbind(sb_distances, sb_loc_row)\n}\n}\n\n# sb_distances <- unique...\nwrite.csv(sb_distances, \"data/sb_distances.csv\")\n\n### SKIP TO HERE\n\n# Mapping\n\n# Bringing in the dataframe because I don't want to make you wait through a loop\nsb_distances <- read.csv(\"data/sb_distances.csv\")\n\n# Arranging and filtering just the 10 locations with the shortest distances\nsb_10 <- sb_distances %>%\narrange(feet) %>%\nfilter(feet > 60) %>%\nhead(40)\n\nsb_solo <- select(sb_10, lat, lon, feet)\nsb_solo2 <- select(sb_10, sb_lat, sb_lon, feet)\ncolnames(sb_solo2) <- c(\"lat\", \"lon\", \"feet\")\n\nsb_again <- rbind(sb_solo, sb_solo2)\n\n# Mapping it\nm <- leaflet(sb_again) %>% addTiles('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', \nattribution='Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>') %>% \nsetView(-98.483330, 38.712046, zoom = 4) %>% \naddCircleMarkers(~lon, ~lat, popup=sb_again$feet, weight = 3, radius=4, \ncolor=\"#13ED3F\", stroke = F, fillOpacity = 0.5)  %>%\naddLegend(\"bottomright\", colors= \"#13ED3F\", labels=\"Starbucks\", title=\"End of the Universe\")\n\n\nm\n\n# Making choropleths\n\n# To make a choropleth map, you first need a shapefile or geojson of the polygons that you're filling in. \n\n# Polygon stuff from shape file\n# install.packages(\"tigris\")\nlibrary(tigris)\n\nstates <- states(cb=T)\n\n# Let's quickly map that out\nstates %>% leaflet() %>% addTiles() %>% addPolygons(popup=~NAME)\n\n# Joining data to a shapefile\n\n### Let's make a choropleth map based on number of Starbucks per state\n\n# First, we'll use dplyr to summarize the data\n# count by state\nsb_state <- starbucks %>%\n  group_by(Province) %>%\n  summarize(total=n())\n\n# Some quick adjustments to the the dataframe to clean up names\nsb_state$type <- \"Starbucks\"\ncolnames(sb_state) <- c(\"state\", \"total\", \"type\")\n\n# Now we use the Tigris function geo_join to bring together \n# the states shapefile and the sb_states dataframe -- STUSPS and state \n# are the two columns they'll be joined by\nstates_merged_sb <- geo_join(states, sb_state, \"STUSPS\", \"state\")\n\n# Creating a color palette based on the number range in the total column\npal <- colorNumeric(\"Greens\", domain=states_merged_sb$total)\n\n# Getting rid of rows with NA values\nstates_merged_sb <- subset(states_merged_sb, !is.na(total))\n\n# Setting up the pop up text\npopup_sb <- paste0(\"Total: \", as.character(states_merged_sb$total))\n\n# Mapping it with the new tiles CartoDB.Positron\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addPolygons(data = states_merged_sb , \n              fillColor = ~pal(states_merged_sb$total), \n              fillOpacity = 0.7, \n              weight = 0.2, \n              smoothFactor = 0.2, \n              popup = ~popup_sb) %>%\n  addLegend(pal = pal, \n            values = states_merged_sb$total, \n            position = \"bottomright\", \n            title = \"Starbucks\")\n\n\n# What's the problem here. You know what's wrong.\n\n# This is essentially a population map.\n\n# So we need to adjust for population.\n\n# And that's easy to do using the Census API.\n\n# Bringing in Census data via API\n\n# install.packages(\"devtools\")\n# devtools::install_github(\"hrecht/censusapi\")\n\nlibrary(censusapi)\n\n# Pulling in the key.R script that has my census api key. \n# It will be disabled after this weekend so get your own\n# http://api.census.gov/data/key_signup.html\n\nsource(\"key.R\") \n\n# We won't go over all the functions, but uncomment the lines below to see \n# the available variables \n# vars2015 <- listCensusMetadata(name=\"acs5\", vintage=2015, \"v\")\n# View(vars2015)\n\n# Alright, getting total population by state from the API\nstate_pop <-  getCensus(name=\"acs5\", \n                        vintage=2015,\n                        key=census_key, \n                        vars=c(\"NAME\", \"B01003_001E\"), \n                        region=\"state:*\")\n\ndatatable(head(state_pop))\n\n# Cleaning up the column names\ncolnames(state_pop) <- c(\"NAME\", \"state_id\", \"population\")\nstate_pop$state_id <- as.numeric(state_pop$state_id)\n# Hm, data comes in numbers of fully spelled out, not abbreviations\n\n# Did you know R has its own built in list of State names and State abbreviations?\n# Just pull it in this way to create a dataframe for reference\n\nstate_off <- data.frame(state.abb, state.name)\n\n# So I needed to create the dataframe above because the Census API data \n# gave me states with full names while the Starbucks data came with abbreviated state names\n# So I needed a relationship dataframe so I could join the two\n\n# Cleaning up the names for easier joining\ncolnames(state_off) <- c(\"state\", \"NAME\")\n\n# Joining state population dataframe to relationship file\nstate_pop <- left_join(state_pop, state_off)\n\n# The relationship dataframe didnt have DC or Puerto Rico, so I'm manually putting those in\nstate_pop$state <- ifelse(state_pop$NAME==\"District of Columbia\", \"DC\", as.character(state_pop$state))\nstate_pop$state <- ifelse(state_pop$NAME==\"Puerto Rico\", \"PR\", as.character(state_pop$state))\n\n# Joining Starbucks dataframe to adjusted state population dataframe\nsb_state_pop <- left_join(sb_state, state_pop)\n\n# Calculating per Starbucks stores 100,000 residents and rounding to 2 digits\nsb_state_pop$per_capita <- round(sb_state_pop$total/sb_state_pop$population*100000,2)\n\n# Eliminating rows with NA\nsb_state_pop <- subset(sb_state_pop, !is.na(per_capita))\ndatatable(head(sb_state_pop))\n\n# Final map\n\n\nstates_merged_sb_pc <- geo_join(states, sb_state_pop, \"STUSPS\", \"state\")\n\npal_sb <- colorNumeric(\"Greens\", domain=states_merged_sb_pc$per_capita)\nstates_merged_sb_pc <- subset(states_merged_sb_pc, !is.na(per_capita))\n\npopup_sb <- paste0(\"Per capita: \", as.character(states_merged_sb_pc$per_capita))\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  setView(-98.483330, 38.712046, zoom = 4) %>% \n  addPolygons(data = states_merged_sb_pc , \n              fillColor = ~pal_sb(states_merged_sb_pc$per_capita), \n              fillOpacity = 0.9, \n              weight = 0.2, \n              smoothFactor = 0.2, \n              popup = ~popup_sb) %>%\n  addLegend(pal = pal_sb, \n            values = states_merged_sb_pc$per_capita, \n            position = \"bottomright\", \n            title = \"Starbucks<br />per 100,000<br/>residents\")\n\n",
    "created" : 1496938307005.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4120117532",
    "id" : "1FFD8F88",
    "lastKnownWriteTime" : 1496938344,
    "last_content_update" : 1496938344361,
    "path" : "~/Documents/Github/IRE/2017/r-mapping/leaflet-r.R",
    "project_path" : "leaflet-r.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}